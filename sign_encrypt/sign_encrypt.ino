#include <TweetNaCl2.h>

TweetNaCl2 tuit;

  
byte arduinoSignSK[crypto_sign_SECRETKEYBYTES]
    = { 0x74,0xc5,0x5a,0xcc,0x8b,0xa0,0x8f,0x01,
        0xec,0x2b,0xed,0x47,0x4f,0x64,0x15,0x5a,
        0x4c,0xb3,0x7a,0x61,0x71,0x66,0xf5,0x58,
        0xb4,0x83,0xc7,0x29,0x47,0x68,0xc6,0x40,
        0xb6,0xa6,0x83,0x9a,0x41,0x03,0x25,0xb1,
        0xc8,0x04,0x33,0xc1,0x19,0x50,0xdd,0x26,
        0x96,0x62,0xb1,0x67,0xe9,0x0b,0xa5,0x46,
        0xe7,0x48,0x5f,0xa9,0x15,0x10,0x2e,0x51 };

 const byte arduinosk[crypto_box_SECRETKEYBYTES]
    = { 0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 
        0x3c, 0x16, 0xc1, 0x72, 0x51, 0xb2, 0x66, 0x45, 
        0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0, 0x99, 0x2a, 
        0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a };

  const byte serverpk[crypto_box_PUBLICKEYBYTES] 
    = { 0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 
        0xd3, 0x5b, 0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 
        0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78, 0x67, 0x4d, 
        0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f };

const byte nonce[crypto_box_NONCEBYTES]
    = { 0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73,
        0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc, 0x73, 0xd6,
        0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37 };

 byte m[41] 
    = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xde, 0x61, 0x18, 0x0c, 0x6f, 0x72, 0xb9, 0x66,
        0x2a};
        
int const mlen = 41;

unsigned char smtemp[mlen+crypto_sign_BYTES];
; //41 + 64 +32

unsigned long long smlen = 0;



void setup() {

  Serial.begin(9600);
  Serial.println("start");
  
  int i;
 
  int Suc_Sign=20;
  Suc_Sign = tuit.crypto_sign(smtemp, &smlen, m, mlen, arduinoSignSK);
  
  Serial.println(" ");
  Serial.print("Successful Signature ");
  Serial.println(Suc_Sign);
  Serial.print("signed message length");
  Serial.println((int) smlen);
  Serial.println();
  
  for(i=0;i<smlen;i++){
    Serial.print(" ,0x");
       Serial.print(smtemp[i],HEX);
       if(i%8==7){
         Serial.println();
       }
  }
  
  Serial.println();
  byte sc[137];
 
  unsigned char sm[mlen+crypto_sign_BYTES+32]
  for(i=0;i<32;i++){
    sm[i]=0;
  }
  for(i=0;i<137;i++){
     sm[32+i]=smtemp[i]; 
  }
  
   for(i=0;i<137;i++){
       Serial.print(" ,0x");
       Serial.print(sm[i],HEX);
       if(i%8==7){
         Serial.println();
       }
     } 
  
  Serial.println(" ");
  Serial.print("signed message length ");
  int fulllength = smlen + 32;
  Serial.println(fulllength);
  
 
  
  int Suc_Encry=20;
  Suc_Encry = tuit.crypto_box(sc, sm, 137, nonce, serverpk, arduinosk);
  
  Serial.print("successful encrypt ");
  Serial.println(Suc_Encry);
  
  //int smsize = sizeof(sm);
  for(i=0;i<137;i++){
       Serial.print(" ,0x");
       Serial.print(sc[i],HEX);
       if(i%8==7){
         Serial.println();
       }
     } 
     
}

void loop() {
//  signature shoud be
//   ,0x13 ,0xA7 ,0x1B ,0xC6 ,0x8 ,0x1 ,0xD4 ,0xDB
// ,0x13 ,0xB ,0x33 ,0x38 ,0x3F ,0xF2 ,0xDE ,0xCD
// ,0xD4 ,0xC4 ,0xDD ,0xAA ,0x59 ,0x8C ,0xDC ,0x6F
// ,0x76 ,0x3B ,0x78 ,0xDB ,0xAE ,0x94 ,0x11 ,0x23
// ,0x31 ,0x6F ,0x9E ,0xA2 ,0x4 ,0xFC ,0x54 ,0x5B
// ,0xBC ,0xBD ,0x3B ,0x85 ,0xB4 ,0x32 ,0xBB ,0xC3
// ,0x54 ,0x66 ,0xE0 ,0xCD ,0x2F ,0xE7 ,0xDC ,0x11
// ,0x12 ,0x1C ,0xFC ,0xAE ,0x54 ,0xEE ,0xC4 ,0x8
// ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0
// ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0
// ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0
// ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0
// ,0xDE ,0x61 ,0x18 ,0xC ,0x6F ,0x72 ,0xB9 ,0x66
// ,0x2A

}
