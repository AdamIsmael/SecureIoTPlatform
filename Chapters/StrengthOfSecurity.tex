%Chapter of secureness
%How safe is my app, what attacks can it stand up against and why

\chapter{Strength Of Security}
\label{stre}

%Has this become the results section??
%In the result, you simply display results, don't discuss, that's for critical evaluation

\section{Sign then Encrypt}

Generally encryption stops unauthorised parties from accessing information, assuming authorised parties are the only party with access to a secret key, prove message integrity. Signatures prove that the message came from a known sender and the sender cannot deny sending the message. These are two distinct operations and the order of these operations matters. If a user was to encrypt a message then sign and send it, as the signature is added to the message, it can be stripped off by an attacker and replaced. If the attacker managed to intercept the transmission of public keys in the first place then they can now impersonated the real recipient. Signing after encryption defeats the purpose of signing, which is to prove that the owner of the signature saw the data and cannot disprove that if their signature is attached to it. If an encrypted message is signed then it is entirely possible that the owner of the signature was not aware what was in the message. In this application the message is signed first so the hash is taken of the plaintext message and it can be proved that the signer was aware as to the contents of the message and then it is encrypted\cite{signencrypt}.


\section{Storing data in plaintext}

Storing vital data such as passwords and usernames in plain text in a database is generally considered quite a bad idea. This provides one point of failure that if broken means that every password stored is now useless and the accounts are wide open. In some circumstances that initial break might not seem so severe, say if that is for a forum site where the worst action that could be taken was writing an inappropriate message but users sometimes use the same password for many different sites. Although in this application the information being stored in temperature data and not passwords but the security implications are still there. This application would have that single point of failure that is so deplorable. It is necessary to provide as many layers of security as possible rather than have one hard layer. That being the security of the database. As such this application stores all the temperature data as it arrives, in it's encrypted form. This way the keys will need to be known by the attacker in order to gain the data.
%should be in hash or something better as we'd need to store all the keys and work out what key to use on what data if we ever wanted access.

\section{Public Key Transmission}

If the keys are preinstalled they can be used to sign and encrypt new public keys before they are sent. So that the receiver can use the presinstalled keys to prove integrity and authenticity of the new keys. If there are no preinstalled keys then there is no way to prove that the public key being received is indeed the public key sent. At least for a computer. The most secure and safe method to make sure the keys are the same is to have a human user manually inspected the key before sending and after sending and carefully ascertain that the one sent is correct. If there has been a man in the middle, MITM, and either the key has been altered or replaced entirely then the human user can see the difference. 

\section{Bit Flipping}

Bit flipping is the process of changing parts of the encrypted message so that it says something else. This is especially potent when the format of the message is know. As the format of the message is know to us, a test can be set that if it succeeds would change a number. In this project a test was set up to demonstrate the cryptography caused detected that the message had been altered in transit. After a signed message was encrypted it was altered with random hexadecimal numbers and it each time the decryption process would fail. The encryption process adds a hash of the message and the decryption process would find a different hash and would fail each time.

\section{Timing Attacks}

TweetNaCl is an example of constant time software, which means that the time of execution does not depend on secret data and is therefore not vulnerable to timing attacks. To have this quality TweetNaCl avoids all loads from address and all branch conditions that depend on secret data and it is thus inherently protected against cache timing attacks. 

\section{Replay Attacks}

This attack is the act of resending of captured valid messages to repeat a valid action, like sending money or authentication. The potential for serious damage by a replay attack here is limited as this application. If an attacker resends some data to the server, say a malicious set of temperature data, when the server would go to decrypt that message it would try to use the incorrect nonce and public key and the message would be ignore, thus protecting the application from replay attacks.

\section{Length of cipher text}

Is it possible to gain information about the message from looking at characteristics of the cipher text? In bad cipher text it can be possible to find out the types of message that are sent as the resulting ciphertext may have change in a certain, predictable. For example if the message is a large number in contrast to a low number, there may be noticeable differences. Unfortunately a vulnerability exists in the cryptography chosen but it is a common weakness and one that does not have much consequence. That is the length of the cipher text corresponds with the length of the message. This is offset somewhat by the additition of the signature so the cipher text is much larger than one would expect if it was know that 9 bytes of hexadecimal were sent. To fully get around this the message is padded out with zeros so that the whole message is always forty one bytes in length. Which does mean the message has a limit of forty one bytes unless the source code is altered. To test how the cipher text changes when sending different messages four encryptions took place. The messages were YES, NO, 1 and 9999. 

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | p{7cm} | }
	\hline
	Plaintext Message & Encrypted Message \\ \hline
	YES & 0xAE, 0x43, 0xCD, 0xA5, 0x8E, 0x54, 0xE9,  0x30, 0x59, 0xB1, 0xD5, 0xA5, 0xBF, 0x24, 0x9D, 0xEE, 0x69, 0xDB, 0x37  \\ \hline
	NO &  0x2E, 0xBC, 0xCC, 0x6B, 0x9E, 0xDB, 0x29, 0x64, 0xF6, 0x26, 0x49, 0xEF, 0xE9, 0xFA, 0xBD, 0x9C, 0x7E, 0xD1 \\ \hline
	\end{tabular}
	\caption{Resulting ciphers for encrypting words}
	\label{tab:yesno}
\end{table}

From theses message it is possible to tell the number of bytes sent if you know that the encryption method adds 16 extra bytes but other than that this test shows there isn't a discernible difference between encrypting YES and NO.

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | p{7cm} | }
	\hline
	Plaintext Message & Encrypted Message \\ \hline
	00 & 0x5B, 0x74, 0x76, 0x4C, 0xF4, 0x19, 0x65, 0x37, 0xC4, 0x53, 0xAF, 0xB0, 0xCE, 0x18, 0x1, 0x1, 0x30, 0x9E \\ \hline
	1 & 0x49, 0x1B, 0x1E, 0x52, 0x10, 0x38, 0xD7, 0x38, 0x30, 0x65, 0x71, 0xBC, 0xEE, 0x65, 0x3D, 0x6, 0x31, 0x9E\\ \hline
	99999 & 0xC, 0xC, 0x29, 0xE2, 0x4E, 0x81, 0x67, 0x5, 0x78, 0x49, 0x8C, 0xA1, 0x4F, 0x69, 0x8, 0xBB, 0x9, 0xA7, 0x5D, 0x63, 0x4D \\ \hline
	\end{tabular}
	\caption{Resulting ciphers for encrypting numbers}
	\label{tab:9999}
\end{table}

Again, the bytes return from encrypting the test case of numbers don't indicate that the integer contained in the message is increasing but it does show the length of the number.



%getting the encryption and decryption to have the same nonce
