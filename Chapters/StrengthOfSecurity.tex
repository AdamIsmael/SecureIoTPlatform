%Chapter of secureness
%How safe is my app, what attacks can it stand up against and why

\chapter{Strength Of Security}
\label{stre}

%Has this become the results section??
%In the result, you simply display results, don't discuss, that's for critical evaluation

\section{Encrypt then sign}

Generally encryption stops unauthorised parties from accessing information, assuming authorised parties are the only party with access to a secret key, and prove message integrity. Signatures prove that the message came from a known sender and the sender cannot deny sending the message. These are two distinct operations and the order of these operations matters. If a user was to encrypt a message then sign and send it, as the signature is added to the plain text message, it can be stripped off by an attacker. They can now use the signature to impersonated the real recipient. Signing after encryption partly defeats the purpose of signing, which is to prove that the owner of the signature saw the data and cannot disprove that they didn't send it if their signature is attached to it. If an encrypted message is signed then it is entirely possible that the owner of the signature was not aware what was in the message. In this application the message is signed first so the hash is taken of the plaintext message before being encrypted and it can be proved that the signer was aware of the message contents\cite{signencrypt}.


\section{Storing data in plaintext}

Storing vital data such as passwords and usernames in plain text in a database is generally considered quite a bad idea. This provides one point of failure that if broken means that every password stored is now useless and the accounts are wide open. In some circumstances that initial break might not seem so severe, say if that is for a forum site where the worst action that could be taken was writing an inappropriate message but users sometimes use the same password for many different sites. Although in this application the information being stored in temperature data and not passwords but the security implications are still there. This application would have that single point of failure. It is necessary to provide as many layers of security as possible rather than have one hard outer layer. That being the security of the database. As such this application stores all the temperature data as it arrives, in it's encrypted form. This way if an attacker gains access to the database they will need to know all the keys as well in order to gain the data.
%should be in hash or something better as we'd need to store all the keys and work out what key to use on what data if we ever wanted access.

\section{Public Key Transmission}

If the keys are preinstalled they can be used to sign and encrypt new public keys before they are sent. So that the receiver can use the preinstalled keys to prove integrity and authenticity of the new keys. If there are no preinstalled keys then there is no way to prove that the public key being received is indeed the public key sent. At least for a computer. The most secure and safe method to make sure the keys are the same is to have a human user manually inspected the key before sending and after sending and carefully ascertain that the one sent is correct. If there has been a man in the middle, MITM, and either the key has been altered or replaced entirely then the human user can see the difference. 

\section{Bit Flipping}

Bit flipping is the process of changing parts of the encrypted message so that it says something else. This is especially potent when the format of the message is know. As the format of the message is know to us, a test can be set that if it succeeds would change a number. In this project a test was set up to demonstrate TweetNaCl detected that the message had been altered in transit. After a message was encrypted it was altered with random hexadecimal numbers and it each time the decryption process would fail. The encryption process adds a hash of the message and the decryption process would find a different hash and would fail each time. The encrypted temperature data will not decrypt if the encrypted message has been altered and therefore won't be displayed.

\section{Timing Attacks}

TweetNaCl is an example of constant time software, which means that the time of execution does not depend on secret data and is therefore not vulnerable to timing attacks. To have this quality TweetNaCl avoids all loads from address and all branch conditions that depend on secret data and it is thus inherently protected against cache timing attacks. 

\section{Replay Attacks}

This attack is the act of resending captured valid messages to repeat a valid action, like sending money or authentication. The potential for serious damage by a replay attack here is limited. If an attacker resends some data to the server, say a malicious set of temperature data, when the server would go to decrypt that message it would try to use the incorrect nonce and public key and the message would be ignored, thus protecting the application from replay attacks.

\section{Cipher Text Characteristics}

It is possible to find out the length of the message when it is encrypted with TweetNaCl. For example if the message is a very long message in contrast to a short message there are noticeable differences. It is a vulnerability that exists in the cryptography chosen but it is a common weakness and one that does not have much consequence. Although the attacker might not know if the message was signed first, it still provides only two options for the length. If the length can be found from the cipher text is it possible for any other details to be leaked out. If the message is of a really high number, does that mean that more of the byte values are higher or conversely if it is a very low number. To test this and look at the output for different String messages, the messages were YES, NO, 1 and 9999 were encrypted. 

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | p{7cm} | }
	\hline
	Plaintext Message & Encrypted Message \\ \hline
	YES & 0xAE, 0x43, 0xCD, 0xA5, 0x8E, 0x54, 0xE9,  0x30, 0x59, 0xB1, 0xD5, 0xA5, 0xBF, 0x24, 0x9D, 0xEE, 0x69, 0xDB, 0x37  \\ \hline
	NO &  0x2E, 0xBC, 0xCC, 0x6B, 0x9E, 0xDB, 0x29, 0x64, 0xF6, 0x26, 0x49, 0xEF, 0xE9, 0xFA, 0xBD, 0x9C, 0x7E, 0xD1 \\ \hline
	\end{tabular}
	\caption{Resulting ciphers for encrypting words}
	\label{tab:yesno}
\end{table}

From theses message it is possible to tell the number of bytes sent if you know that the encryption method adds 16 extra bytes but other than that this test shows there isn't a discernible difference between encrypting YES and NO.

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | p{7cm} | }
	\hline
	Plaintext Message & Encrypted Message \\ \hline
	00 & 0x5B, 0x74, 0x76, 0x4C, 0xF4, 0x19, 0x65, 0x37, 0xC4, 0x53, 0xAF, 0xB0, 0xCE, 0x18, 0x1, 0x1, 0x30, 0x9E \\ \hline
	1 & 0x49, 0x1B, 0x1E, 0x52, 0x10, 0x38, 0xD7, 0x38, 0x30, 0x65, 0x71, 0xBC, 0xEE, 0x65, 0x3D, 0x6, 0x31, 0x9E\\ \hline
	99999 & 0xC, 0xC, 0x29, 0xE2, 0x4E, 0x81, 0x67, 0x5, 0x78, 0x49, 0x8C, 0xA1, 0x4F, 0x69, 0x8, 0xBB, 0x9, 0xA7, 0x5D, 0x63, 0x4D \\ \hline
	\end{tabular}
	\caption{Resulting ciphers for encrypting numbers}
	\label{tab:9999}
\end{table}

Again, the bytes return from encrypting the test case of numbers don't indicate that the integer contained in the message is increasing in magnitude but it does show that the number is increasing in length. If the numbers were 111 and 554 the message length would be no indicator and no information would be leaked.



%getting the encryption and decryption to have the same nonce
