%Chapter of secureness
%How safe is my app, what attacks can it stand up against and why

\chapter{Strength Of Security}
\label{stre}

%Has this become the results section??
%In the result, you simply display results, don't discuss, that's for critical evaluation

\section{Sign then Encrypt}

Encryption stops unauthorised parties from accessing information, assuming authorised parties are the only party with access to a secret key. Signatures prove the message was not altered in transit, integrity, that the message came from a known sender and that sender cannot deny sending the message. These are two distinct operations and the order of these operations matters. If a user was to encrypt a message then sign and send it, as the signature is added to the message it can be stripped off by an attacker and replaced with their own. If the attacker managed to intercept the transmission of public keys in the first place then they can now impersonated the real recipient. Or they could change the message content through a bit banging attack and because there is no hash of the message to be compared to the receiver can't know if the message integrity has failed. In addition the attack can add any signature to the message, encrypting then signing does not prove that the owner of the signature was aware what was in the message as it was encrypted. In this application the message is signed first so the hash is taken of the plaintext message and it can be proved that the signer was aware as to the contents of the message and then it is encrypted.

can protect against the attacks mentioned earlier because...

%http://world.std.com/~dtd/sign_encrypt/sign_encrypt7.html

\section{Storing data in plaintext}

Storing vital data such as passwords and usernames in plain text in a database is an absolutely horrendous idea. This provides one point of failure that if broken means that every password stored is now useless and the accounts are wide open. In some circumstances that initial break might not be so severe, say if that is for forum site where the worst action that could be taken was writing a mean message but users sometimes use the same password for many different sites. Although in this application the temperature data is being store and not passwords the security implications are still there. This application would have that single point of failure that is so deplorable. It is necessary to provide as many layers of security as possible rather than have one hard layer. That being the security of the database. As such this application stores all the temperature data as it arrives, in it's encrypted form. This way the keys will need to be known by the attacker in order to gain the data.
%should be in hash or something better as we'd need to store all the keys and work out what key to use on what data if we ever wanted access.

\section{Public Key Transmission}

If the keys are preinstalled they can be used to sign and encrypt new public keys before they are sent. So that the receiver can use the presinstalled keys to prove integrity and authenticity of the new keys. If there are no preinstalled keys then there is no way to prove that the public key being received is indeed the public key sent. At least for a computer. The most secure and safe method to make sure the keys are the same is to have a human user manually inspected the key before sending and after sending and carefully ascertain that the one sent is correct. If there has been a man in the middle, MITM, and either the key has been altered or replaced entirely then the human user can see the difference. 

\section{Bit Flipping}

Bit flipping is the process of changing parts of the encrypted message so that it says something else. This is especially potent when the format of the message is know. As the format of the message is know to us, a test can be set that if it succeeds would change a number. If the message had 
In this project a test was set up to demonstrate the cryptography caused detected that the message had been altered in transit.
After a signed message was encrypted it was altered before being decrypted and the signature checked

As the format of the message is known, key areas of the message were altered and the following output notice

The format of the raw plaintext message is 32 leading zeros and 9 bytes of actual information. Where the first two are the temperature. 

when we change the 9th and 8th last hex digits in the resulting cipher text....what happens, decrypts fine but signature fails


Also, encrypt 1 and 9999 to see?


\section{Length of cipher text}

Is it possible to gain information about the message from looking at characteristics of the cipher text? In bad cipher text it can be possible to find out the types of message that are sent as the resulting ciphertext may have change in a certain, predictable. For example if the message is a large number in contrast to a low number, there may be noticeable differences. Unfortunately a vulnerability exists in the cryptography chosen but it is a common weakness and one that does not have much consequence. That is the length of the cipher text corresponds with the length of the message. This is offset somewhat by the additition of the signature so the cipher text is much larger than one would expect if it was know that 9 bytes of hexadecimal were sent. To fully get around this the message is padded out with zeros so that the whole message is always forty one bytes in length. Which does mean the message has a limit of forty one bytes unless the source code is altered. To test how the cipher text changes when sending different messages four encryptions took place. The messages were YES, NO, 1 and 9999. 

sending encrypted the one and 9999
yes and no

To encrypt the hex of the word YES, produces 

,0xAE ,0x43 ,0xCD ,0xA5 ,0x8E ,0x54 ,0xE9 ,0x30
 ,0x59 ,0xB1 ,0xD5 ,0xA5 ,0xBF ,0x24 ,0x9D ,0xEE
 ,0x69 ,0xDB ,0x37
 105, 219, 55

To encrypt the hex of the word NO, produces 

 ,0x2E ,0xBC ,0xCC ,0x6B ,0x9E ,0xDB ,0x29 ,0x64
 ,0xF6 ,0x26 ,0x49 ,0xEF ,0xE9 ,0xFA ,0xBD ,0x9C
 ,0x7E ,0xD1
126, 209

From this message it is possible to tell the number of bytes sent if you know that the encryption method adds 16 extra bytes but other than that this test shows there isn't a discernable difference


To encrypt a message of all zeros
,0x5B ,0x74 ,0x76 ,0x4C ,0xF4 ,0x19 ,0x65 ,0x37
 ,0xC4 ,0x53 ,0xAF ,0xB0 ,0xCE ,0x18 ,0x1 ,0x1
 ,0x30 ,0x9E

To encrypt a message of a 1
,0x49 ,0x1B ,0x1E ,0x52 ,0x10 ,0x38 ,0xD7 ,0x38
 ,0x30 ,0x65 ,0x71 ,0xBC ,0xEE ,0x65 ,0x3D ,0x6
 ,0x31 ,0x9E

To encrypt a message of 99999
,0xC ,0xC ,0x29 ,0xE2 ,0x4E ,0x81 ,0x67 ,0x5
 ,0x78 ,0x49 ,0x8C ,0xA1 ,0x4F ,0x69 ,0x8 ,0xBB
 ,0x9 ,0xA7 ,0x5D ,0x63 ,0x4D

\section{nonces}

getting the encryption and decryption to have the same nonce


573