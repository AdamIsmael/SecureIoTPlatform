%Chapter of secureness
%How safe is my app, what attacks can it stand up against and why

\chapter{Strength Of Security}
\label{stre}

%Has this become the results section??
%In the result, you simply display results, don't discuss, that's for critical evaluation

\section{Naive Sign \& Encrypt or Encrypt \& Sign}

There are problems with naive implementations of Signatures and Encryption. Both encrypting and then signing and vice versa. If a plaintext message is signed by Alice and sent to Bob encrypted with his public key. Bob can decrypt the ciphertext and re-encrypt with Charlies public key before sending it to Charlie. When Charlie decrypts the message using his private key and verifies the signature with Alices public key he finds that Alice sent the message. Charlie has been tricked by Bob into thinking Alice has sent he a message. If the opposite were to happen, if Alice sent a message to Bob that she encrypted before signing. Charlie can capture the message, strip off Alice's signature, replace with his own and take credit for the message. One assumes that Charlie knows what the message will contain. Also, by signing a cipher text it can no longer be proved that the owner of the signature was aware of the message contents. These are fairly rare edge cases but they should still be considered. It could be argued that Alice should not have trusted her first message with Bob or that an individual should never sign a cipher text because they don't know what the message contains. Or that Charlie should not assume that if he recieveds a signed message that he was defintely the intended recipient.      However, these are weak arguments as humans are not infallible, mistakes happen and there can never be a guarantee the receiver is trustworthy \cite{signencrypt}.


This application gets around those problems by using TweetNaCl's authenticated encryption as well as a signature and prepending the messages before encryption and signature with the Arduino's own unique identifier and the unique identifier of who it sent the message to. By using authenticated encryption the server can validate the message was sent by the Arduino, had not been altered in transit nor viewed by another party. After decryption the server is still able to re-encrypt with it's another party's public key and send it to them and prove that it was originally sent by the Arduino. The signature provides another layer of security as the server can prove again that the message sent by the Arduino is the same as received and it can use the two identifiers to prove that the Arduino sent it to the server. The server can't surreptitiously forward the message without changing one of the unique identifiers and therefore invalidating the signature.



%Generally encryption stops unauthorised parties from accessing information, assuming authorised parties are the only party with access to a secret key, and prove message integrity. Signatures prove that the message came from a known sender and the sender cannot deny sending the message. These are two distinct operations and the order of these operations matters. If a user was to encrypt a message then sign and send it, as the signature is added to the plain text message, it can be stripped off by an attacker. They can now use the signature to impersonated the real recipient. Signing after encryption partly defeats the purpose of signing, which is to prove that the owner of the signature saw the data and cannot disprove that they didn't send it if their signature is attached to it. If an encrypted message is signed then it is entirely possible that the owner of the signature was not aware what was in the message. In this application the message is signed first so the hash is taken of the plaintext message before being encrypted and it can be proved that the signer was aware of the message contents\cite{signencrypt}.


\section{Storing data in plaintext}

Storing vital data such as passwords and usernames in plain text in a database is generally considered quite a bad idea. This provides one point of failure that if broken means that every password stored is now useless and the accounts are wide open. In some circumstances that initial break might not seem so severe, say if that is for a forum site where the worst action that could be taken was writing an inappropriate message but users sometimes use the same password for many different sites. Although in this application the information being stored in temperature data and not passwords but the security implications are still there. This application would have that single point of failure. It is necessary to provide as many layers of security as possible rather than have one hard outer layer. That being the security of the database. As such this application stores all the temperature data as it arrives, in it's encrypted form. This way if an attacker gains access to the database they will need to know all the keys as well in order to gain the data.
%should be in hash or something better as we'd need to store all the keys and work out what key to use on what data if we ever wanted access.

\section{Public Key Transmission}

If the keys are preinstalled they can be used to sign and encrypt new public keys before they are sent. So that the receiver can use the preinstalled keys to prove integrity and authenticity of the new keys. If there are no preinstalled keys then there is no way to prove that the public key being received is indeed the public key sent. At least for a computer. The most secure and safe method to make sure the keys are the same is to have a human user manually inspected the key before sending and after sending and carefully ascertain that the one sent is correct. If there has been a man in the middle, MITM, and either the key has been altered or replaced entirely then the human user can see the difference. 

\section{Bit Flipping}

Bit flipping is the process of changing parts of the encrypted message so that it says something else. This is especially potent when the format of the message is know. As the format of the message is know to us, a test can be set that if it succeeds would change a number. In this project a test was set up to demonstrate TweetNaCl detected that the message had been altered in transit. After a message was encrypted it was altered with random hexadecimal numbers and it each time the decryption process would fail. The encryption process adds a hash of the message and the decryption process would find a different hash and would fail each time. The encrypted temperature data will not decrypt if the encrypted message has been altered and therefore won't be displayed.

\section{Timing Attacks}

TweetNaCl is an example of constant time software, which means that the time of execution does not depend on secret data and is therefore not vulnerable to timing attacks. To have this quality TweetNaCl avoids all loads from address and all branch conditions that depend on secret data and it is thus inherently protected against cache timing attacks. 

\section{Replay Attacks}

This attack is the act of resending captured valid messages to repeat a valid action, like sending money or authentication. The potential for serious damage by a replay attack here is limited. If an attacker resends some data to the server, say a malicious set of temperature data, when the server would go to decrypt that message it would try to use the incorrect nonce and public key and the message would be ignored, thus protecting the application from replay attacks.

\section{Cipher Text Characteristics}

It is possible to find out the length of the message when it is encrypted with TweetNaCl. For example if the message is a very long message in contrast to a short message there are noticeable differences. It is a vulnerability that exists in the cryptography chosen but it is a common weakness and one that does not have much consequence. Although the attacker might not know if the message was signed first, it still provides only two options for the length. If the length can be found from the cipher text is it possible for any other details to be leaked out. If the message is of a really high number, does that mean that more of the byte values are higher or conversely if it is a very low number. To test this and look at the output for different String messages, the messages were YES, NO, 0, 1 and 99999 were encrypted. 

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | p{7cm} | }
	\hline
	Plaintext Message & Encrypted Message \\ \hline
	YES & 0xAE, 0x43, 0xCD, 0xA5, 0x8E, 0x54, 0xE9,  0x30, 0x59, 0xB1, 0xD5, 0xA5, 0xBF, 0x24, 0x9D, 0xEE, 0x69, 0xDB, 0x37  \\ \hline
	NO &  0x2E, 0xBC, 0xCC, 0x6B, 0x9E, 0xDB, 0x29, 0x64, 0xF6, 0x26, 0x49, 0xEF, 0xE9, 0xFA, 0xBD, 0x9C, 0x7E, 0xD1 \\ \hline
	\end{tabular}
	\caption{Resulting ciphers for encrypting words}
	\label{tab:yesno}
\end{table}

From theses message it is possible to tell the number of bytes sent if you know that the encryption method adds 16 extra bytes but other than that this test shows there isn't a discernible difference between encrypting YES and NO.

\begin{table}[H]
	\centering
	\begin{tabular}{ | l | p{7cm} | }
	\hline
	Plaintext Message & Encrypted Message \\ \hline
	0 & 0x5B, 0x74, 0x76, 0x4C, 0xF4, 0x19, 0x65, 0x37, 0xC4, 0x53, 0xAF, 0xB0, 0xCE, 0x18, 0x01, 0x01, 0x30, 0x9E \\ \hline
	1 & 0x49, 0x1B, 0x1E, 0x52, 0x10, 0x38, 0xD7, 0x38, 0x30, 0x65, 0x71, 0xBC, 0xEE, 0x65, 0x3D, 0x6, 0x31, 0x9E\\ \hline
	99999 & 0x0C, 0x0C, 0x29, 0xE2, 0x4E, 0x81, 0x67, 0x05, 0x78, 0x49, 0x8C, 0xA1, 0x4F, 0x69, 0x08, 0xBB, 0x09, 0xA7, 0x5D, 0x63, 0x4D \\ \hline
	\end{tabular}
	\caption{Resulting ciphers for encrypting numbers}
	\label{tab:9999}
\end{table}

Again, the bytes return from encrypting the test case of numbers don't indicate that the integer contained in the message is increasing in magnitude but it does show that the number is increasing in length. If the numbers were 111 and 554 the message length would be no indicator and no information would be leaked. One solution to this is to pad out the message so that it was always a set length. With a set message length a message's length would need to be the set message length or shorter. If the message was shorter then extra characters are put in to mask the true length of the message, thus messages of variable length could be sent without altering the length of the cipher text, this wasn't included to the project due to time constraints.  



%getting the encryption and decryption to have the same nonce
